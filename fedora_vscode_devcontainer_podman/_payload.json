[{"data":1,"prerenderedAt":587},["ShallowReactive",2],{"fedora_vscode_devcontainer_podman":3,"title|vue_stack_development_devcontainer":549,"Related_fedora_vscode_devcontainer_podman":550},{"title":4,"description":5,"img":6,"readingTime":7,"createdAt":12,"updatedAt":12,"slug":13,"tags":14,"category":20,"body":21},"在Fedora中透過podman使用VSCode DevContainer","之前在中曾經紀錄過如何使用 VSCode DevContainer 來容器化開發 Vue 專案，但因為自己平常用的作業系統是 Fedora，而 Fedora 內建的容器化引擎是 Podman，雖然 Podman 號稱與 Docker 之間的指令是互通的，但之前嘗試過會有錯誤而且一直找不到解方。","923/i8GwZw.jpg",{"text":8,"minutes":9,"time":10,"words":11},"4 min read",3.655,219300,731,"2024-11-03T03:18:44.000Z","fedora_vscode_devcontainer_podman",[15,16,17,18,19],"fedora","podman","docker","vscode","devcontainer","frontend",{"type":22,"children":23,"toc":540},"root",[24,39,44,48,55,60,77,83,88,91,97,147,186,206,209,221,233,458,501,504,509,534],{"type":25,"tag":26,"props":27,"children":28},"element","p",{},[29,32,37],{"type":30,"value":31},"text","之前在",{"type":25,"tag":33,"props":34,"children":36},"article-inner-link",{"slug":35},"vue_stack_development_devcontainer",[],{"type":30,"value":38},"中曾經紀錄過如何使用 VSCode DevContainer 來容器化開發 Vue 專案，但因為自己平常用的作業系統是 Fedora，而 Fedora 內建的容器化引擎是 Podman，雖然 Podman 號稱與 Docker 之間的指令是互通的，但之前嘗試過會有錯誤而且一直找不到解方。",{"type":25,"tag":26,"props":40,"children":41},{},[42],{"type":30,"value":43},"不過這幾天趁著要把筆電重灌成 Fedora 41 的勢頭，又嘗試從網路上尋找方法除錯，還真的被我找到了，於是就記錄下來，不然覺得要額外安裝 Docker 實在有點麻煩。",{"type":25,"tag":45,"props":46,"children":47},"hr",{},[],{"type":25,"tag":49,"props":50,"children":52},"h2",{"id":51},"podman-簡介",[53],{"type":30,"value":54},"Podman 簡介",{"type":25,"tag":26,"props":56,"children":57},{},[58],{"type":30,"value":59},"總之呢，Podman 是 Redhat 公司所推出的，一款跟 Docker 一樣是開放原始碼的容器管理工具。與 Docker 最大的差異是 Podman 預設都是無根權限的，沒有所謂的「守護進程」，Podman 比起 Docker 開源的部份更多、更符合 OCI 規範。",{"type":25,"tag":61,"props":62,"children":63},"article-note",{},[64,66,75],{"type":30,"value":65},"\n關於 Podman 的詳細介紹以及與 Docker 的比較，可參考\n",{"type":25,"tag":67,"props":68,"children":72},"a",{"href":69,"rel":70},"https://www.redhat.com/en/topics/containers/what-is-podman",[71],"nofollow",[73],{"type":30,"value":74},"Redhat 官方文章",{"type":30,"value":76},"\n。\n",{"type":25,"tag":78,"props":79,"children":81},"h3",{"id":80},"遇到的問題",[82],{"type":30,"value":80},{"type":25,"tag":26,"props":84,"children":85},{},[86],{"type":30,"value":87},"在 VSCode DevContainer 中使用 Podman 替代 Docker 最大的問題，就是使用者權限錯亂，這會導致在 Podman 中運作的 DevContainer 看不到專案結構與目錄，也無法修改、建立檔案。",{"type":25,"tag":45,"props":89,"children":90},{},[],{"type":25,"tag":49,"props":92,"children":94},{"id":93},"前置作業安裝模擬-docker-的-podman-套件",[95],{"type":30,"value":96},"前置作業：安裝模擬 Docker 的 Podman 套件",{"type":25,"tag":26,"props":98,"children":99},{},[100,102,108,110,115,117,123,125,130,132,137,139,145],{"type":30,"value":101},"雖然可以透過調整 VSCode 的設定值來讓 DevContainer 所呼叫的指令從",{"type":25,"tag":103,"props":104,"children":106},"code",{"className":105},[],[107],{"type":30,"value":17},{"type":30,"value":109},"改用",{"type":25,"tag":103,"props":111,"children":113},{"className":112},[],[114],{"type":30,"value":16},{"type":30,"value":116},"，但 Fedora 有內建一個很方便的套件叫做",{"type":25,"tag":103,"props":118,"children":120},{"className":119},[],[121],{"type":30,"value":122},"podman-docker",{"type":30,"value":124},"，它會自動使用",{"type":25,"tag":103,"props":126,"children":128},{"className":127},[],[129],{"type":30,"value":16},{"type":30,"value":131},"來接收",{"type":25,"tag":103,"props":133,"children":135},{"className":134},[],[136],{"type":30,"value":17},{"type":30,"value":138},"的指令，並且調整相關變數（例如",{"type":25,"tag":103,"props":140,"children":142},{"className":141},[],[143],{"type":30,"value":144},"$DOCKER_HOST",{"type":30,"value":146},"），比起自己一個一個設定會來得方便許多。那麼來安裝它：",{"type":25,"tag":148,"props":149,"children":154},"pre",{"className":150,"code":151,"language":152,"meta":153,"style":153},"language-bash shiki shiki-themes github-dark","sudo dnf install podman-docker\n","bash","",[155],{"type":25,"tag":103,"props":156,"children":157},{"__ignoreMap":153},[158],{"type":25,"tag":159,"props":160,"children":163},"span",{"class":161,"line":162},"line",1,[164,170,176,181],{"type":25,"tag":159,"props":165,"children":167},{"style":166},"--shiki-default:#B392F0",[168],{"type":30,"value":169},"sudo",{"type":25,"tag":159,"props":171,"children":173},{"style":172},"--shiki-default:#9ECBFF",[174],{"type":30,"value":175}," dnf",{"type":25,"tag":159,"props":177,"children":178},{"style":172},[179],{"type":30,"value":180}," install",{"type":25,"tag":159,"props":182,"children":183},{"style":172},[184],{"type":30,"value":185}," podman-docker\n",{"type":25,"tag":61,"props":187,"children":188},{},[189,191,198,200,205],{"type":30,"value":190},"\n若有先安裝 Docker，建議先完全移除後重新開機，此部份可參考\n",{"type":25,"tag":67,"props":192,"children":195},{"href":193,"rel":194},"https://docs.docker.com/engine/install/fedora/#uninstall-docker-engine",[71],[196],{"type":30,"value":197},"官方文件",{"type":30,"value":199},"\n，然後再安裝\n",{"type":25,"tag":103,"props":201,"children":203},{"className":202},[],[204],{"type":30,"value":122},{"type":30,"value":76},{"type":25,"tag":45,"props":207,"children":208},{},[],{"type":25,"tag":49,"props":210,"children":212},{"id":211},"調整devcontainerjson",[213,215],{"type":30,"value":214},"調整",{"type":25,"tag":103,"props":216,"children":218},{"className":217},[],[219],{"type":30,"value":220},"devcontainer.json",{"type":25,"tag":26,"props":222,"children":223},{},[224,226,231],{"type":30,"value":225},"在上網找了很多文章之後，嘗試出來的解法是修改",{"type":25,"tag":103,"props":227,"children":229},{"className":228},[],[230],{"type":30,"value":220},{"type":30,"value":232},"的設定，長這樣：",{"type":25,"tag":148,"props":234,"children":238},{"className":235,"code":236,"filename":220,"language":237,"meta":153,"style":153},"language-json shiki shiki-themes github-dark","{\n  /* 這兩行是使用內建指令建立開發者容器時就有的 */\n  \"name\": \"Node.js\",\n  \"image\": \"mcr.microsoft.com/devcontainers/javascript-node:1-20-bookworm\",\n  /* 下面這四行才是為了Podman加的 */\n  \"runArgs\": [\"--userns=keep-id\"],\n  // 這裡的「node」似乎是要跟容器內部預設的使用者名稱相同\n  \"containerEnv\": {\n    \"HOME\": \"/home/node\"\n  },\n  // 這裡的target網路是直接寫/workspace，不過為了區分我加上了自己的專案資料夾路徑。\n  \"workspaceMount\": \"source=${localWorkspaceFolder},target=/workspace/blog,type=bind,Z\",\n  // 這裡的網路是直接寫/workspace，不過為了區分我加上了自己的專案資料夾路徑。\n  \"workspaceFolder\": \"/workspace/blog\"\n}\n","json",[239],{"type":25,"tag":103,"props":240,"children":241},{"__ignoreMap":153},[242,251,261,286,308,317,341,350,364,382,391,400,422,431,449],{"type":25,"tag":159,"props":243,"children":244},{"class":161,"line":162},[245],{"type":25,"tag":159,"props":246,"children":248},{"style":247},"--shiki-default:#E1E4E8",[249],{"type":30,"value":250},"{\n",{"type":25,"tag":159,"props":252,"children":254},{"class":161,"line":253},2,[255],{"type":25,"tag":159,"props":256,"children":258},{"style":257},"--shiki-default:#6A737D",[259],{"type":30,"value":260},"  /* 這兩行是使用內建指令建立開發者容器時就有的 */\n",{"type":25,"tag":159,"props":262,"children":264},{"class":161,"line":263},3,[265,271,276,281],{"type":25,"tag":159,"props":266,"children":268},{"style":267},"--shiki-default:#79B8FF",[269],{"type":30,"value":270},"  \"name\"",{"type":25,"tag":159,"props":272,"children":273},{"style":247},[274],{"type":30,"value":275},": ",{"type":25,"tag":159,"props":277,"children":278},{"style":172},[279],{"type":30,"value":280},"\"Node.js\"",{"type":25,"tag":159,"props":282,"children":283},{"style":247},[284],{"type":30,"value":285},",\n",{"type":25,"tag":159,"props":287,"children":289},{"class":161,"line":288},4,[290,295,299,304],{"type":25,"tag":159,"props":291,"children":292},{"style":267},[293],{"type":30,"value":294},"  \"image\"",{"type":25,"tag":159,"props":296,"children":297},{"style":247},[298],{"type":30,"value":275},{"type":25,"tag":159,"props":300,"children":301},{"style":172},[302],{"type":30,"value":303},"\"mcr.microsoft.com/devcontainers/javascript-node:1-20-bookworm\"",{"type":25,"tag":159,"props":305,"children":306},{"style":247},[307],{"type":30,"value":285},{"type":25,"tag":159,"props":309,"children":311},{"class":161,"line":310},5,[312],{"type":25,"tag":159,"props":313,"children":314},{"style":257},[315],{"type":30,"value":316},"  /* 下面這四行才是為了Podman加的 */\n",{"type":25,"tag":159,"props":318,"children":320},{"class":161,"line":319},6,[321,326,331,336],{"type":25,"tag":159,"props":322,"children":323},{"style":267},[324],{"type":30,"value":325},"  \"runArgs\"",{"type":25,"tag":159,"props":327,"children":328},{"style":247},[329],{"type":30,"value":330},": [",{"type":25,"tag":159,"props":332,"children":333},{"style":172},[334],{"type":30,"value":335},"\"--userns=keep-id\"",{"type":25,"tag":159,"props":337,"children":338},{"style":247},[339],{"type":30,"value":340},"],\n",{"type":25,"tag":159,"props":342,"children":344},{"class":161,"line":343},7,[345],{"type":25,"tag":159,"props":346,"children":347},{"style":257},[348],{"type":30,"value":349},"  // 這裡的「node」似乎是要跟容器內部預設的使用者名稱相同\n",{"type":25,"tag":159,"props":351,"children":353},{"class":161,"line":352},8,[354,359],{"type":25,"tag":159,"props":355,"children":356},{"style":267},[357],{"type":30,"value":358},"  \"containerEnv\"",{"type":25,"tag":159,"props":360,"children":361},{"style":247},[362],{"type":30,"value":363},": {\n",{"type":25,"tag":159,"props":365,"children":367},{"class":161,"line":366},9,[368,373,377],{"type":25,"tag":159,"props":369,"children":370},{"style":267},[371],{"type":30,"value":372},"    \"HOME\"",{"type":25,"tag":159,"props":374,"children":375},{"style":247},[376],{"type":30,"value":275},{"type":25,"tag":159,"props":378,"children":379},{"style":172},[380],{"type":30,"value":381},"\"/home/node\"\n",{"type":25,"tag":159,"props":383,"children":385},{"class":161,"line":384},10,[386],{"type":25,"tag":159,"props":387,"children":388},{"style":247},[389],{"type":30,"value":390},"  },\n",{"type":25,"tag":159,"props":392,"children":394},{"class":161,"line":393},11,[395],{"type":25,"tag":159,"props":396,"children":397},{"style":257},[398],{"type":30,"value":399},"  // 這裡的target網路是直接寫/workspace，不過為了區分我加上了自己的專案資料夾路徑。\n",{"type":25,"tag":159,"props":401,"children":403},{"class":161,"line":402},12,[404,409,413,418],{"type":25,"tag":159,"props":405,"children":406},{"style":267},[407],{"type":30,"value":408},"  \"workspaceMount\"",{"type":25,"tag":159,"props":410,"children":411},{"style":247},[412],{"type":30,"value":275},{"type":25,"tag":159,"props":414,"children":415},{"style":172},[416],{"type":30,"value":417},"\"source=${localWorkspaceFolder},target=/workspace/blog,type=bind,Z\"",{"type":25,"tag":159,"props":419,"children":420},{"style":247},[421],{"type":30,"value":285},{"type":25,"tag":159,"props":423,"children":425},{"class":161,"line":424},13,[426],{"type":25,"tag":159,"props":427,"children":428},{"style":257},[429],{"type":30,"value":430},"  // 這裡的網路是直接寫/workspace，不過為了區分我加上了自己的專案資料夾路徑。\n",{"type":25,"tag":159,"props":432,"children":434},{"class":161,"line":433},14,[435,440,444],{"type":25,"tag":159,"props":436,"children":437},{"style":267},[438],{"type":30,"value":439},"  \"workspaceFolder\"",{"type":25,"tag":159,"props":441,"children":442},{"style":247},[443],{"type":30,"value":275},{"type":25,"tag":159,"props":445,"children":446},{"style":172},[447],{"type":30,"value":448},"\"/workspace/blog\"\n",{"type":25,"tag":159,"props":450,"children":452},{"class":161,"line":451},15,[453],{"type":25,"tag":159,"props":454,"children":455},{"style":247},[456],{"type":30,"value":457},"}\n",{"type":25,"tag":26,"props":459,"children":460},{},[461,463,469,471,477,478,484,486,492,494,499],{"type":30,"value":462},"老實說我也不是很懂為什麼這樣就能解決問題，但問了 ChatGPT 跟自己查找一些資料之後，應該是透過",{"type":25,"tag":103,"props":464,"children":466},{"className":465},[],[467],{"type":30,"value":468},"runArgs",{"type":30,"value":470}," / ",{"type":25,"tag":103,"props":472,"children":474},{"className":473},[],[475],{"type":30,"value":476},"containerEnv",{"type":30,"value":470},{"type":25,"tag":103,"props":479,"children":481},{"className":480},[],[482],{"type":30,"value":483},"workspaceMount",{"type":30,"value":485},"去統一了容器內外的使用者及權限，來解決 Podman 預設無根的權限問題，",{"type":25,"tag":103,"props":487,"children":489},{"className":488},[],[490],{"type":30,"value":491},"workspaceFolder",{"type":30,"value":493},"只是配合",{"type":25,"tag":103,"props":495,"children":497},{"className":496},[],[498],{"type":30,"value":483},{"type":30,"value":500},"的掛載路徑，讓容器內的工作目錄一起動就會定位在專案下，來讓流程更直觀一點。",{"type":25,"tag":45,"props":502,"children":503},{},[],{"type":25,"tag":49,"props":505,"children":507},{"id":506},"參考文章",[508],{"type":30,"value":506},{"type":25,"tag":510,"props":511,"children":512},"ul",{},[513,524],{"type":25,"tag":514,"props":515,"children":516},"li",{},[517],{"type":25,"tag":67,"props":518,"children":521},{"href":519,"rel":520},"https://code.visualstudio.com/remote/advancedcontainers/docker-options#_podman",[71],[522],{"type":30,"value":523},"Alternate ways to install Docker",{"type":25,"tag":514,"props":525,"children":526},{},[527],{"type":25,"tag":67,"props":528,"children":531},{"href":529,"rel":530},"https://gist.github.com/dariuszparys/05ad6b0bf070cda64724b668f35c897c",[71],[532],{"type":30,"value":533},"Running Visual Studio Code DevContainers with Podman",{"type":25,"tag":535,"props":536,"children":537},"style",{},[538],{"type":30,"value":539},"html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}",{"title":153,"searchDepth":253,"depth":253,"links":541},[542,545,546,548],{"id":51,"depth":253,"text":54,"children":543},[544],{"id":80,"depth":263,"text":80},{"id":93,"depth":253,"text":96},{"id":211,"depth":253,"text":547},"調整devcontainer.json",{"id":506,"depth":253,"text":506},"使用VSCode搭配DevContainer容器化開發Vue專案",[551,561,574],{"title":549,"description":552,"img":553,"tags":554,"readingTime":555,"createdAt":559,"updatedAt":560,"slug":35},"在這個什麼都可以容器化的年代，開發也是可以容器化的。容器化的好處多多，其中自己覺得最重要的部份就是不再需要寫繁雜的設定步驟文件流傳後代（？），只要寫好 dockerfile，就能 1:1 重製開發環境。","924/uCCnpK.jpg",[17,18,19],{"text":8,"minutes":556,"time":557,"words":558},3.225,193500,645,"2024-06-02T12:48:40.000Z","2024-11-03T03:26:44.000Z",{"title":562,"description":563,"img":564,"tags":565,"readingTime":566,"createdAt":571,"updatedAt":572,"slug":573},"在Fedora 38中安裝Docker","本篇記錄了在 Fedora 中安裝及安裝後設定 Docker 的過程。","924/lduYJH.jpg",[15,17],{"text":567,"minutes":568,"time":569,"words":570},"1 min read",0.875,52500,175,"2023-04-08T08:01:46.000Z","2023-12-11T03:54:57.000Z","fedora_docker_startup",{"title":575,"description":576,"tags":577,"img":578,"readingTime":579,"createdAt":584,"updatedAt":585,"slug":586},"Fedora初始設定紀錄","本篇是將自己重灌 Fedora 時會做的一些事情，例如：移除沒在用的 Gnome 預設程式、安裝自己要用的程式、更新……等等的過程，以指令碼的形式紀錄下來，以求下次重灌完可以直接複製貼上執行之後就會最接近自己平常的使用狀態。",[15],"922/m6wo1h.jpg",{"text":580,"minutes":581,"time":582,"words":583},"3 min read",2.375,142500,475,"2023-01-02T08:03:40.000Z","2024-11-02T03:50:15.000Z","fedora_startup",1740151898228]